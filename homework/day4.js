// ·Day4  js

// 1.用自己的话描述js垃圾回收机制

/**
 * 
 * 1.    标记清除
工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

工作流程：

    1.    垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。

    2.    去掉环境中的变量以及被环境中的变量引用的变量的标记。

    3.    再被加上标记的会被视为准备删除的变量。

    4.    垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。

2.    引用计数
工作原理：跟踪记录每个值被引用的次数。

工作流程：

    1.    声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。

    2.    同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.

    3.    当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.

    4.    当引用次数变成0时，说明没办法访问这个值了。

    5.    当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。

function test() {

  var a = {}; //a的引用次数为0

  var b = a; //a的引用次数加1，为1

  var c = a; //a的引用次数再加1，为2

  var b = {}; //a的引用次数减1，为1

}

        当出现上面这种相互引用的时候，JS的垃圾回收机制，就无法回收内存，浪费大量性能。

    3.    优化
        引入分代回收策略，即存在相互引用的时候，他们的引用计数减去 1 为 0 时，就回收，

点

 */


// 3.深入理解this执行
function Foo() {
    getName = function() { alert(1); }
    return this
}
Foo.getName = function() { alert(2); }
Foo.prototype.getName = function() { alert(3); }
var getName = function () { alert(4); }
function getName() { alert(5); }

// 输出值？ 请写出原因
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName()
new Foo().getName()
new new Foo().getName()


// 4. 重绘和回流（重排）的区别和关系 用自己的话描述
/**当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 
 * 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。
 * 在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，
 * 完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘
 */

/**回流的产生：
1.页面第一次渲染 在页面发生首次渲染的时候，所有组件都要进行首次布局，这是开销最大的一次回流。
2.浏览器窗口尺寸改变
3.元素位置和尺寸发生改变的时候
4.新增和删除可见元素
5.内容发生改变（文字数量或图片大小等等）
6.元素字体大小变化。
7.激活CSS伪类（例如：:hover）。
8.设置style属性
9.查询某些属性或调用某些方法。比如说：
offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight
除此之外，当我们调用getComputedStyle方法，或者IE里的currentStyle时，也会触发回流，原理是一样的，都为求一个“即时性”和“准确性”。

重绘的产生：
当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如
visibility、outline、背景色等属性的改变。



*/
